## Repeated Transactions
Repeated Transactions (23.28%).
|Serial number| Reporting time |  Bug link  | Root cause | Exploitation method | Fix strategy  |
|    :---:    |      :---:     |    :---:    |      :---:     |      :---:     |      :---:     |
|1|2021-05-03|[2021-04-marginswap#h-07](https://code4rena.com/reports/2021-04-marginswap#h-07-accountholdstoken-is-never-set)| There is a lack of mapping to avoid repeatedly depositing the same token. | Multiple deposits of the same token resulted in duplicate token records in the account. holdingTokens array. | Set the holdsToken map in addHolding() to distinguish different tokens.
|2|2021-08-30|[2021-05-visorfinance#h-02](https://code4rena.com/reports/2021-05-visorfinance#h-02-nft-transfer-approvals-are-not-removed-and-cannot-be-revoked-thus-leading-to-loss-of-nft-tokens)|The granted NFT transaction authorization is not revoked.|The authorization has not been revoked, and the authorized person can transfer NFTs repeatedly. | Modify the status variables that control the granting or revocation of permissions.
|3|2021-08-30|[2021-05-visorfinance#h-03](https://code4rena.com/reports/2021-05-visorfinance#h-03-approval-for-nft-transfers-is-not-removed-after-transfer) | Failure to clear the approval authorization for NFT resulted in authorized agents being able to transfer the NFT multiple times. | The NFT authorization is not reset.| Reset the approval on transfer.
|4|2021-11-30|[2021-09-sushitrident-2#h-03](https://code4rena.com/reports/2021-09-sushitrident-2#h-03-concentratedliquiditypoolmanagers-incentives-can-be-stolen)|The reclaimIncentive function does not decrement the incentive.rewardsUnclaimed field. | The attacker repeatedly called the recaaimIncentive function to steal all tokens in the incentive pool. | Decrement the incentive.rewardsUnclaimed field by the withdrawn amount.
|5|2021-11-23|[2021-10-mochi#h-06](https://code4rena.com/reports/2021-10-mochi#h-06-referrer-can-drain-referralfeepoolv0)|The claimRewardAsMochi function does not reduce the user's reward balance. | The referrer can repeatedly claim the same reward until the fee pool is exhausted. | Decrement the user's reward balance in the claimRewardAsMochi function.
|6|2021-11-23|[2021-10-mochi#h-11](https://code4rena.com/reports/2021-10-mochi#h-11-treasuryshare-is-overwritten-in-feepoolv0_sharemochi)| The _shareMochi() function incorrectly resets treasuryShare. | VeCRV holders can receive tokens that should have been allocated to treasure multiple times. | Remove the operation that resets treasuryShare.
|7|2022-04-20|[2021-11-unlock#h-03](https://code4rena.com/reports/2021-11-unlock#h-03-mixintransfersoltransferfrom-wrong-implementation-can-potentially-allows-attackers-to-reverse-transfer-and-cause-fund-loss-to-the-users)|The key manager is not reset. | The attacker repeats the transaction after the key transfer, either returning the key to themselves or transferring it to other recipients. | Reset the key manager in the transferFrom function.
|8|2022-04-20|[2021-11-unlock#h-04](https://code4rena.com/reports/2021-11-unlock#h-04-approvals-not-cleared-after-key-transfer)|The _setKeyManagerOf function does not clear single-token approvals. | The attacker repeatedly transfers the key back to themselves from the victim without clearing the previous approval after the key transfer. | Call the _clearApproval function to clear the approval.
|9|2022-03-24|[2022-01-behodler#h-04](https://code4rena.com/reports/2022-01-behodler#h-04-logic-error-in-burnflashgovernanceasset-can-cause-locked-assets-to-be-stolen)| Reset the user's pendingFlashDecision to default configuration when processing pending governance decisions. | The attacker repeatedly calls withdrawGovernanceAsset to steal funds. | Properly clear the user's pendingFlashDecision state in the burnFlashGovernanceAsset() function.
|10|2023-01-18|[2022-02-anchor#h-01](https://code4rena.com/reports/2022-02-anchor#h-01-spend-limit-on-owner-can-be-bypassed)|The spend_limit is not decremented based on spent amounts. | config.spend_limit was not reduced after each spend, causing all subsequent spends to bypass the limit and the attacker could call the spend function multiple times. | After the spending operation is successful, reduce the value of config.spend_limit accordingly.
|11|2023-01-20|[2022-11-stakehouse#h-16](https://code4rena.com/reports/2022-11-stakehouse#h-16-reentrancy-vulnerability-in-giantmevandfeespoolwithdraweth)| beforeTokenTransfer() is called before the ETH transfer occurs. | After receiving ETH, the attacker used the unlocked claimRewards() function to perform multiple transactions, resulting in too many rewards being issued. | Perform the "idleETH -= _amount;" operation after burning the LP tokens.
|12|2023-02-28|[2022-12-forgeries#h-01](https://code4rena.com/reports/2022-12-forgeries#h-01-admin-does-not-have-to-wait-to-call-lastresorttimelockownerclaimnft)| The recoverTimelock is not updated with each lottery draw. | Administrators can bypass the waiting time limit by repeatedly calling lastResortTimelockOwnerClaimNFT() without waiting for the specified time lock period to expire. | Update recoverTimelock with every lottery draw.
|13|2023-04-05|[2022-07-golom#h-04](https://code4rena.com/reports/2022-07-golom#h-04-old-delegatee-not-deleted-when-delegating-to-new-tokenid)|The old delegatee is not removed. | The old delegators were not deleted, resulting in the same user being able to double-count voting rights by delegating the same token multiple times. | remove the user's old delegation before executing a new operation.
|14|2023-04-11|[2023-01-rabbithole#h-02](https://code4rena.com/reports/2023-01-rabbithole#h-02-protocol-fees-can-be-withdrawn-multiple-times-in-erc20quest)|The fee withdrawal status is not updated. | The withdrawFee() function does not have any protection mechanism, allowing the protocol fee to be withdrawn multiple times. | Track the protocol fee withdrawal status.
|15|2023-04-18|[2022-12-tessera#h-04](https://code4rena.com/reports/2022-12-tessera#h-04-optimisticlistingseaportpropose-sets-pendingbalances-of-newly-added-proposer-instead-of-previous-one)| Update pendingBalances only after new proposal creation. | The old proposer loses the deposit, and the new proposer can repeat the proposal. | Update pendingBalances before calling _setListing().
|16|2023-04-18|[2022-12-tessera#h-03](https://code4rena.com/reports/2022-12-tessera#h-03-groupbuy_verifyunsuccessfulstate-and-_verifysuccessfulstate-both-can-return-true-when-blocktimestamp--poolterminationperiod)|Both _verifyUnsuccessfulState() and _verifySuccessfulState() functions return true for the terminationPeriod timestamp.  | The attacker stole funds by repeatedly claiming already refunded funds. | Change the time comparison condition in the _verifySuccessfulState() function from "<" to "<=".
|17|2023-06-23|[2023-04-party#h-08](https://code4rena.com/reports/2023-04-party#h-08-vetoproposal-user-can-veto-multiple-times-so-every-proposal-can-be-vetoed-by-any-user-that-has-a-small-amount-of-votes)| A mapping for tracking whether a veto vote has been cast is missing. | Users can vote down the same proposal multiple times, allowing users with a small number of votes to veto any proposal. | Add a hasVoted map to track whether each (party, proposalId, address) triple has already cast a veto vote.
|18|2023-11-29|[2023-09-venus#h-01](https://code4rena.com/reports/2023-09-venus#h-01-primesol---user-can-claim-prime-token-without-having-any-staked-xvs-because-his-stakedat-isnt-reset-whenever-he-is-issued-an-irrevocable-token)|The stakedAt timestamp is not reinitialized when a user obtains non-revocable Prime tokens. | Users repeatedly claim Prime token without pledging XVS. | Reinitialize the stakedAt timestamp when issuing non-revocable Prime tokens.
|19|2024-03-20|[2024-01-renft#h-07](https://code4rena.com/reports/2024-01-renft#h-07-attacker-can-lock-lender-nfts-and-erc20-in-the-safe-if-the-offer-is-set-to-partial)| Different hash values corresponding to different orders are lacking. | Creating multiple similar partially filled orders results in the same order hash value, which allows the partial asset to be locked. | Introduce a random number (nonce) for each order to ensure that the orderHash is unique.
|20|2024-06-17|[2024-04-dyad#h-01](https://code4rena.com/reports/2024-04-dyad#h-01-design-flaw-and-mismanagement-in-vault-licensing-leads-to-double-counting-in-collateral-ratios-and-positions-collateralized-entirely-with-kerosine)|The keroseneVault is not authorized to the KerosineManager. | The attacker registers the same asset to both management systems at the same time, causing the asset to be counted twice. | Manage keroseneVault and regular vault in separate mappings, used for price calculation and authorization management respectively.
|21|2024-07-28|[2024-06-playfi-proleague#h-1](https://github.com/code-423n4/zenith-portfolio/tree/main/reports)|The variable limiting user purchase quantity is not updated after license purchase. | The attacker calls the claimLicensePartner() or claimLicensePublic() functions multiple times to repeatedly purchase licenses without restriction. | Accurately record each user's purchase quantity to prevent overbuying.
|22|2024-07-13|[2024-06-strateg-proleague#h-4](https://github.com/code-423n4/zenith-portfolio/tree/main/reports)| lastClaimTotalRewards only updates when feeClaimable is greater than 0. | The attacker transferred the balances of the two tokenIds and stole the rewards from the contract multiple times by repeatedly claiming the rewards. | Update the variables lastClaimTotalRewards and timeClaimed before the feeClaimable check.
|23|2024-07-13|[2024-06-strateg-proleague#h-1](https://github.com/code-423n4/zenith-portfolio/tree/main/reports)| There is a lack of a list of processed tokens to ensure that the same generation of tokens will not be counted multiple times. | The attacker repeatedly calculated the balance of Token B, inflated the total assets, and then obtained more shares at a low price. | Add deduplication logic in the oracleExit() function to ensure that the same generation of coins is not calculated multiple times.
|24|2024-08-16|[2024-07-optimism#h-03](https://code4rena.com/reports/2024-07-optimism#h-03-lpp-metadata-can-be-altered-after-the-challenge-period-is-over-allowing-incorrect-states-to-be-proven)| In the initLPP function, the LPPMetadata data structure is not initialized. | Repeatedly calling the initLPP() function modifies the claimedSize and partOffset of LPP, resulting in incorrect state hashing. | Remove unnecessary storage reads in the initLPP function. Additionally, add a check in the squeezeLPP function to ensure that bytesProcessed must be equal to claimedSize.
|25|2024-09-13|[2024-09-legion-evm-zenith#h-3](https://github.com/code-423n4/zenith-portfolio/tree/main/reports)| A Boolean flag indicating whether the funds have been withdrawn is missing. | The withdrawCapital() function can be called multiple times until all remaining capital in the contract is withdrawn. | Add a Boolean flag tokensWithdrawn to indicate whether funds have been withdrawn.
|26|2024-10-07|[2024-08-phi#h-04](https://code4rena.com/reports/2024-08-phi#h-04-forced-endtime-extension-in-updateartsettings-allows-attacker-to-mint-more-tokens)|The endTime is incorrectly updated to block.timestamp in updateArtSettings().  | The attacker exploited the extended endTime to repeat the transaction and mint additional tokens. | Separate the update logic for "uri", "soulBounded", and "royalty" config. Additionally, change the ">" to ">=" in the time validation condition.
|27|2024-10-18|[2024-08-superposition#h-02](https://code4rena.com/reports/2024-08-superposition#h-02-unrevoked-approvals-allow-nft-recovery-by-previous-owner)|The previous getApproved[_tokenId] approval status is not revoked. | Approval was not revoked after the NFT was transferred, and the previous owner transferred the NFT back to himself through repeated transactions. | Clear the approval status after transferring the NFT.
